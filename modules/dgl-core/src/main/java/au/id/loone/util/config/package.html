<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!--
  ~ Copyright 2009, David G Loone
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~   http://www.apache.org/licenses/LICENSE-2.0
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<html>
  <head>
    <title>Per-instance configuration tools</title>
  </head>
  <body>
    Per-instance configuration tools.

    <p>This configuration framework is a tiered configuration system
      that facilitates an identical deployment unit to be deployed to various environments
      (dev, test, stating, production, etc),
      and configured via a the minimum required number of settings
      that live outside the deploymemnt unit.
      The tiered nature of the framework provides a mechanism whereby
      global configuration can be provided via this class directly,
      but it can be extended by sub-modules to provide configuration data local to that module.</p>

    <h3><a name="Motivation">Motivation</a></h3>

    <p>We often need to include nominally constant or quasi-constant values in our code.
      By constant here,
      we mean that the value probably does not change over the life of the application.
      By quasi-constant,
      we mean that the value might be set at the beginning of the lifecycle of the application,
      and probably won't change later,
      but for various reasons we need to reserve the right to change the value later on.
      Some people also advocate externalising all constant values from the source code,
      probably more for idealogical reasons than anything.</p>

    <p>In any case,
      a mechanism for externalising data from our application source code.
      The most common practical reason for needing to do so
      is that we desire to deploy one deployment archive into several environments,
      where each of those environments has its own set of configuration details.
      Most often,
      these confuration details are around connecting to external resources
      (databases, web services, etc).</p>

    <p>This configuration framework is derived from the following principles:</p>
    <ol>
      <li>Each piece of data should become typesafe as early as possible in the lifecycle of the data item.
        A common question that is asked is: "What will be affected if I change this property in the
        configuration file?".
        Modern IDEs are good at tracing usage of typesafe data,
        but this is only of use if we know exactly what pieces of code access the properties file.
        Therefore,
        our configuration framework encourages the practice of having one and only one piece of code
        accessing a given configuration property,
        and exposing that configuration property in a typesafe way for use by the application,
        thus making it possible to track usage of the data from there.</li>
      <li>Each deployment environment should be required to provide only the minimum set of configuration data
        that distinguishes it from a baseline.
        In practical terms,
        this means that the deployment unit should be able to provide (internal) defaults for configuration data
        (where appropriate)
        and each environment should only have to provide configuration data where it needs to override those
        defaults.</li>
      <li>The configuration data loaded into a particular application instnace
        should be made available at runtime as appliction metadata
        (via CMX or whatever).</li>
      <li>Should be easy to use, etc etc etc.</li>
    </ol>

    <h3><a name="BasicUse">Creating and Populating Config Beans</a></h3>

    <p>Creating and maintaining configuration data is straightforward.
      We generally want to configure a subsystem,
      usually encapsulated in a package,
      using a config bean.
      A config bean is just a class that extends {@link au.id.loone.util.config.ConfigData}
      (directly or indirectly),
      that has a number of bean properties that encapsulate the configuration needs of the subsystem.</p>

    <p>A config bean is accompanied by a properties resource of the same name and location as the class,
      but with an extension of "<code>.properties</code>"
      (the class config properties file).
      Bean properties on the config bean are automatically configured from that properties resource.
      Keys in the properties resorce are the bean property names,
      and values in the property resource are the bean property values.
      The {@link au.id.loone.util.beans.DGLBeanUtil} class is used to populate the config bean properties,
      so a rich variety of possibilities for config bean properties is available.</p>

    <p>For example:</p>
    <table align="center" border="1" cellpadding="3" cellspacing="0" width="90%">
      <tr>
        <td><pre style="margin: 0px;">package my.package;

public class DataServiceConfig
     extends {@link au.id.loone.util.config.ConfigData ConfigData}
{

   private int maxRows;

   private {@link java.net.URI URI} serviceLocation;

   public DataServiceConfig()
   {
       {@link au.id.loone.util.config.ConfigData#ConfigData() super}();
   }

   public void setMaxRows(
           final int maxRows
   }
   {
       this.maxRows = maxRows;
   }

   public int getMaxRows()
   {
       return maxRows;
   }

   public void setServiceLocation(
           final {@link java.net.URL URL} serviceLocation
   )
   {
       this.serviceLocation = serviceLoation;
   }

   public {@link java.net.URL URL} getServiceLocation()
   {
       return serviceLocation;
   }

}</pre>
        </td>
      </tr>
    </table>

    <table align="center" border="1" cellpadding="3" cellspacing="0" width="90%">
      <tr>
        <td><pre style="margin: 0px;"># /my/package/DataServiceConfig.properties

maxRows=3
serviceLocation=http://localhost:8080</pre>
        </td>
      </tr>
    </table>

    <p>In this example,
      the <code>dataServiceConfig</code> class is the config bean class.
      On construction of the <code>DataServiceConfig</code> class
      (by whatever means),
      the <code>DataServiceConfig.properties</code> file is read
      and the key/value pairs contained therein are used to set bean properties on the bean.</p>

    <p>Bean properties on the config bean shoud be as strongly typed as possible,
      with conversion being performed by the {@link au.id.loone.util.beans.DGLBeanUtil} class.
      Because the config bean properties are strongly typed,
      and the config properties resoruce is only exposed via bean properties on the config bean,
      it is possible to trace usage of conifiguration data using normal IDE tools.</p>

    <p><strong>Note: </strong>
      Because of the execution ordering of object creation in Java,
      it is <strong>not</strong> possile to simply set default values for the config bean properties
      by assignment within the config bean.
      This is because the superclass constructor is called <strong>before</strong> local object variables are initialised.
      Thus,
      any values assigned to object variables within the class
      will override the values set by the superclass constructor.</p>

    <h3><a name="AdvancedConfigBeans">Advanced Config Beans</a></h3>

    <p>The actual work of locating and reading the class config properties file
      is performed by the no-args constructor of the {@link au.id.loone.util.config.ConfigData} class.
      In fact,
      this is done for every class in the inheritance hierarchy of the config bean,
      including the {@link au.id.loone.util.config.ConfigData} class.
      This is performed from top to bottom,
      so that data in more specific classes overrides data from less specific classes.
      This provided a mechanism for federating configuration data.
      For example,
      there may be a corporate configuration data bean
      (<code>CorpConfigData</code>) that extends {@link au.id.loone.util.config.ConfigData}
      that provides things like company name, etc.
      It might also provide a bean property like <span style="font-weight: bold;">applicationName</span>,
      but not actually provide a value in its <code>CorpConfigData.properties</code> file.
      Then there might be an application specific config bean
      (<code>AppConfigData</code>) that extends <code>CorpConfigData</code>.
      Even if the <code>AppConfigData</code> does not provide any bean properties of its own,
      its <code>AppConfigData.properties</code> file
      could fill in the <span style="font-weight: bold;">applicationName</span> property.
      There could then be subsystem configurations below that, etc.</p>

    <h3><a name="Configuration">Configuration</a></h3>

    <p>Athough config beans will work quite happily without any configuraiton in place,
      they aren't of much use when used in that way
      (except where a project wishes to start instrumenting the soruce with uses of config beans
      early in the project lifecycle in anticipation of configuration being added later on).
      The value of config beans is that the framework can be configured to override any config bean property
      from an external override file.
      The aim is to provide a single properties file that contains overrides
      for just that subset of config bean properties that must be customised for a given deployment instance.</p>

    <p>Configuration starts by reading the bootstrap properties resource.
      The bootstrap resoruce is in the package directory of the
      {@link au.id.loone.util.config.ConfigData} class,
      and called <code>ConfigDataBootstrap.properties</code>
      (as defined by {@link au.id.loone.util.config.ConfigData#BOOTSTRAP_CONFIG_RESOURCE_PATH}).
      The bootstrap properties resource contains properties that tell
      the {@link au.id.loone.util.config.ConfigData} class how to find an external overrides file
      by describing a list of places for it to look.
      When it finds an external overrides file in one of those places,
      it stops looking and uses that file to override config bean properties in the system.</p>

    <p>The bootstrap properties resource can contain the following properties:</p>
    <table align="center" border="1" cellpadding="3" cellspacing="0" width="90%">
      <thead>
        <tr>
          <th>key</th>
          <th>description</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td align="left" valign="top"><code>allowProceedWithoutOverrides</code></td>
          <td align="left" valign="top">A boolean value that indicates whether the applicaiton can proceed
            if no external overrides can be found.
            If this is set to <code>true</code>
            and no external overrides are found,
            then a runtime exception will be thrown
            from the static initialisation of the {@link au.id.loone.util.config.ConfigData} class,
            which should defeat application startup.
            If this is set to <code>false</code>
            and no external overrides are found,
            then the applicaiton continues with no external overrides.
            The default value is <code>false</code>.</td>
        </tr>
        <tr>
          <td align="left" valign="top"><code>log4jConfigResourceLocation</code></td>
          <td align="left" valign="top">The resource location for the Log4j configuration file.
            The default value is <code>/log4j.properties</code>,
            as defined by {@link au.id.loone.util.config.ConfigData$Log4jConfigProperties#DEFAULT_LOG4J_CONFIG_RESOURCE_LOCATION}.</td>
        </tr>
        <tr>
          <td align="left" valign="top"><code>overrideFinderClassMap[<span style="font-style: italic;">tag</span>]</code></td>
          <td align="left" valign="top">Associates an override finder class with a tag.
            An override finder class is a concrete class that extends {@link au.id.loone.util.config.ConfigData$OverrideFinder}
            (directory or indirectly).
            The <span style="font-style: italic;">tag</span> part of the key indicates the tag being set,
            and can consist only of alpha characters and underscore.
            and the value of the property is the fully qualified class name
            of the class to be associated with that tag.</td>
        </tr>
        <tr>
          <td align="left" valign="top"><code>overrideFinder[<span style="font-style: italic;">index</span>].type</code></td>
          <td align="left" valign="top">Specifies the class for one of the override finders.
            The <span style="font-style: italic;">index</span> part is the index of the override finder.
            The value of the property must be one of the tags
            defined by the <code>overrideFinderClassMap</code> property keys.</td>
        </tr>
        <tr>
          <td align="left" valign="top"><code>overrideFinder[<span style="font-style: italic;">index</span>].<span style="font-style: italic;">propName</span></code></td>
          <td align="left" valign="top">Specifies a bean property for one of the override finders.
            The <span style="font-style: italic;">index</span> part is the index of the override finder
            on which to set the bean property.
            The <span style="font-style: italic;">index</span> part is the name of the bean property to set.
            The value is the string to set into that bean property.</td>
        </tr>
      </tbody>
    </table>

    <p>For example,
      the file contents might look like:</p>
    <table align="center" border="1" cellpadding="3" cellspacing="0" width="90%">
      <tr>
        <td><pre style="margin: 0px;"># ConfigDataBootstrap.properties

allowProceedWithoutOverrides=false

overrideFinderClassMap[FILE]={@link au.id.loone.util.config.ConfigData$FileOverrideFinder au.id.loone.util.config.ConfigData$FileOverrideFinder}
overrideFinderClassMap[RESOURCE]={@link au.id.loone.util.config.ConfigData$ResourceOverrideFinder au.id.loone.util.config.ConfigData$ResourceOverrideFinder}

overrideFinder[0].type=FILE
overrideFinder[0].path=./myApp.properties

overrideFinder[1].type=FILE
overrideFinder[1].path=../myApp.properties

overrideFinder[2].type=RESOURCE
overrideFinder[2].path=/myApp.properties
</pre>
        </td>
      </tr>
    </table>

    <p>This file is suitable for use with Tomcat.
      The first two override finders specify a properties file called <code>myApp.properties</code>
      in the Tomcat configuration directory.
      The first line catches the case where Tomcat is started as a windows service
      (and thus the current working directory is the <code>$CATALINE_HOME</code> directory).
      The second line catches the case where Tomcat is started by executing the statup script
      (and thus, the current working directory is the <code>bin</code> directory).
      The third line allows the override file to exist as a resource
      (at the top of the package tree)
      which is useful for development.</p>

    <p>The <code>overrideFinderClassMap</code> keys provide a mechanism
      by which end users can customse the process of finding the external overrides file.
      The two such definitions given in the example provide a typical configuration,
      in that they use override finder classes that are provided by the framework itself.
      However,
      users can provide their own classes to at can look for external override files in other places.
      Indeed,
      the data does not need to be backed by an actual properties file at all.
      For example,
      an override finder class could be constructed
      that obtains external override properties from a database table.
      An override finder class must simply extend
      {@link au.id.loone.util.config.ConfigData$OverrideFinder}
      and define whatever bean properties are required for it to function properly.
      Those bean properties can be set for individual instances of the class
      by the <code>overrideFinder</code> keys.
      The abstract methods define the functionality that the concrete class must provide.
      Specifically,
      it must be able to say whether the data backing the object exists
      (via the <span style="font-weight: bold;">{@link au.id.loone.util.config.ConfigData$OverrideFinder#getExists() exists}</span> property),
      and gather its data as a {@link java.util.Map} object
      (via the <span style="font-weight: bold;">{@link au.id.loone.util.config.ConfigData$OverrideFinder#getProps() props}</span> property).
      Where appropriate,
      the <span style="font-weight: bold;">{@link au.id.loone.util.config.ConfigData$OverrideFinder#getProps()}</span> method
      should refresh the data from its external entity when the property is read.</p>

    <p>The bootstrap properties file is loaded as a classloader resource by the usual methods.
      The intention is that it is part of the deployment,
      and describes places for the external overrides file
      that work for all environments to which the application will be deployed.
      However, other arrangements are possible.
      For example,
      the bootstrap properties file could be loaded from the classpath,
      and thus itself being external to the deployment,
      could be customised for each deployment environment.</p>

    <h3><a name="Instrumenation">Instrumentation</a></h3>

    <p>Metadata on the state of the configuration data system can be obtained from the
      {@link au.id.loone.util.config.ConfigData$Instrumentation} class.
      This can be used by the application for displaying information pages, etc.</p>

    <h3>Log4j Configuration</h3>

    <p>It is useful to be able to externalise some or all of the Log4j configuration for an application.
      The {@link au.id.loone.util.config.ConfigData$Log4jConfigProperties} class provides
      a {@linkplain java.util.Properties properties} object that consists of data from a config resource,
      augmented by selected values from the external overrides file.</p>

    <p>The {@link au.id.loone.util.config.ConfigData$Log4jConfigProperties#LOG4J_CONFIG_PREFIXES} array
      provides a list of string prefixes.
      All properties in the external overrides file that begin with this prefix
      will override and augment properties obtained from the named properties resource.</p>

    <p>The Log4j configuration facilities supplied herein
      are careful to not use Log4j itself for logging and error reporting.</p>

    <h3>Other Configuration</h3>

    <!-- TODO -->

    <h3>Spring Integration</h3>

    <!-- TODO -->

  </body>
</html>